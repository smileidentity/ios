import Foundation
import CryptoKit
import CommonCrypto


/// An enum which defines the errors that may be thrown by the security class of the framework.
public enum SmileIDCryptoError: Error {
    case deriveKeyError
    case encodingError
    case cantReadSecretValueError
}

/// An enum which defines the file name prefixes of files generated by the SmileID SDK
private enum SmileIDFiles: String {
    case selfie = "si_selfie"
    case liveness = "si_liveness"
    case documentFront = "si_document_front"
    case documentBack = "si_document_back"
}

/// A security class used to protect sensitive information.
public class SmileIDCryptoManager {

    /// The shared singleton instance.
    public static let shared = SmileIDCryptoManager()

    /// Initializes a new instance of the `SmileIDCryptoManager`.
    private init() {}

    /**
     Signs a list of files .
     - Parameters:
       - timestamp: A timestamp of when the signature is being created.
       - files: The files to be protected.
     - Returns: A base64 encoded signature as `String`.
     - Throws: A `SmileIDCryptoError` if the request fails.
     */
    public func sign(timestamp: String, files: [URL]) throws -> String {
        let sortedFiles = files.sorted { $0.lastPathComponent < $1.lastPathComponent }

        var data = Data()
        for file in sortedFiles {
            var fileData = try Data(contentsOf: file)
            if file.lastPathComponent.contains(SmileIDFiles.selfie.rawValue) ||
                file.lastPathComponent.contains(SmileIDFiles.liveness.rawValue) ||
                file.lastPathComponent.contains(SmileIDFiles.documentFront.rawValue) ||
                file.lastPathComponent.contains(SmileIDFiles.documentBack.rawValue) {
                fileData = fileData.base64EncodedData()
            }
            data.append(fileData)
        }

        return try sign(
            timestamp: timestamp,
            payload: data
        )
    }

    /**
     Signs a list of headers and payload .
     - Parameters:
       - timestamp: A timestamp of when the signature is being created.
       - headers: Optional headers to be protected.
       - payload: Optional payload to be protected.
     - Returns: A base64 encoded signature as `String`.
     - Throws: A `SmileIDCryptoError` if the request fails.
     */
    public func sign(timestamp: String, headers: [String: String]? = nil, payload: Data? = nil) throws -> String {
        var data = Data()
        if let headers = headers {
            var filteredHeaders = Dictionary(uniqueKeysWithValues: headers.map { key, value in
                (key.lowercased(), value)
            })
            filteredHeaders = filteredHeaders.filter{ $0.key.hasPrefix("smileid-") }

            data += try JSONSerialization.data(
                withJSONObject: filteredHeaders,
                options: [.sortedKeys, .withoutEscapingSlashes]
            )
        }

        if let payload = payload {
            data += payload
        }

        let salt = String(data.count) + timestamp
        guard let saltData = salt.data(using: .utf8) else {
            throw SmileIDCryptoError.encodingError
        }

        guard let bundle = Bundle(identifier: "com.smileidentity.SmileIDSecurity"),
              let secret = bundle.url(forResource: "SECRET", withExtension: nil) else {
            throw SmileIDCryptoError.cantReadSecretValueError
        }
        var password = try String(contentsOf: secret, encoding: .utf8)
        password = password.trimmingCharacters(in: .whitespacesAndNewlines)

        let key = try deriveKey(salt: saltData, password: password)
        let mac = computeHmac(key: key, data: data)
        return Data(mac).base64EncodedString()
    }

    /**
     Derives a cryptographically secure symmetric key from a password and salt using a password-based
     key derivation function (pbkdf2) from the CommonCrypto library.
     - Parameters:
       - salt: The salt which must be a unique value for every request.
       - password: The password from which the secure cryptographic key is getting derived.
       - keyLength: The length of the resulting symmetric key.
       - iterations: The number of iterations that the KDF is hashing the input.
     - Returns: A cryptographically secure symmetric key as `SymmetricKey`.
     - Throws: A `SmileIDCryptoError` if the request fails.
     */
    private func deriveKey(
        salt: Data,
        password: String,
        keyLength: Int = 32,
        iterations: Int = 200_000
    ) throws -> SymmetricKey {
        guard let passwordData = password.data(using: .utf8) else {
            throw SmileIDCryptoError.encodingError
        }

        var derivedKey = Data(repeating: 0, count: keyLength)
        let result = try derivedKey.withUnsafeMutableBytes { derivedKeyBytes in
            guard let derivedKeyPointer = derivedKeyBytes.baseAddress else {
                throw SmileIDCryptoError.deriveKeyError
            }
            return try salt.withUnsafeBytes { saltBytes in
                guard let saltPointer = saltBytes.baseAddress else {
                    throw SmileIDCryptoError.deriveKeyError
                }
                return CCKeyDerivationPBKDF(
                    CCPBKDFAlgorithm(kCCPBKDF2),
                    password,
                    passwordData.count,
                    saltPointer.assumingMemoryBound(to: UInt8.self),
                    salt.count,
                    CCPBKDFAlgorithm(kCCPRFHmacAlgSHA256),
                    UInt32(iterations),
                    derivedKeyPointer.assumingMemoryBound(to: UInt8.self),
                    keyLength
                )
            }
        }
        guard result == kCCSuccess else {
            throw SmileIDCryptoError.deriveKeyError
        }
        return SymmetricKey.init(data: derivedKey)
    }

    /**
     Computes a message authentication code using the key over the data using a hmac with the
     SHA-256 hash function from the CryptoKit library.
     - Parameters:
       - key: The symmetric key.
       - data: The data to protect.
     - Returns: A message authentication code as `HMAC<SHA256>.MAC`.
     */
    private func computeHmac(key: SymmetricKey, data: Data) -> HMAC<SHA256>.MAC {
        var hmac = HMAC<SHA256>.init(key: key)
        hmac.update(data: data)
        return hmac.finalize()
    }
}
